## 一、网络模型
#### OSI七层模型
- 物理层：IEEE802.1A，RS232
- 数据链路层：
FDDI、Ethernet、PPP
- 网络层：
IP，ICMP，ARP，RARP
- 传输层：
TCP，UDP
- 会话层：
SMTP，DNS
- 表示层：
Telnet
- 应用层：
HTTP、HTTPs
#### TCP/IP四层模型
- 网络接口层：
PPP,HDLC
- 网络层：
IP，ICMP，ARP
- 传输层：
TCP，UDP
- 应用层:
HTTP，DNS，FTP，SMTP

## 二、网络协议
### 应用层协议
#### HTTP请求过程
1. 分析页面URL
2. 域名解析
- 搜索浏览器DNS缓存
- 搜索操作系统DNS缓存
- 读取hosts文件
- 向上一级DNS服务器请求
3. DNS返回URL指向的IP地址
4. 发起TCP/IP的三次握手
5. 浏览器发送请求
6. 服务器响应请求，返回html页面
7. TCP连接释放
8. 渲染页面
#### HTTP报文格式
- 请求报文：请求行，请求首部字段，请求内容实体
- 响应报文：状态行，首部字段，内容实体

### 传输层协议
>TCP和UDP的区别：
>1. UDP最大长度为512字节，TCP允许超过512字节；
>2. TCP通过拥塞控制、超时重传、确认机制等机制是可靠连接，UDP是不可靠的；
>3. TCP面向字节流，UDP面向报文；
>4. TCP是面向连接的，所以实现的是一对一通信，UPD是无连接的，所以可以实现一对多、多对多的通信;
>5. TCP场景:电子邮件，远程终端接入，文件传输；UDP场景：DNS，TFTP，RIP，DHCP，流媒体通信;

#### TCP
#### TCP报文格式
>源端口和目的端口各占16位，Seq序号占32位，ACK确认号占32位，首部长度，保留位，标志位，窗口，校验和，紧急指针
Seq序号，占32位，用来标识从TCP源端向目的端口发送的字节流，发起方发送数据时对此进行标记。
ACK确认好，占32位，只有ACK标志位为1时才有效，Ack=Seq+1
标志位：共6个，URG，ACK，PSH，RST（重置连接），SYN（发起连接），FIN（结束连接），在三次握手中出现
#### 三次握手建立连接
1. 连接过程
>- A请求连接，SYN置1，seq初始随机值x（不携带数据），进入SYN_SENT状态；​B收到请求，回复确认报文，SYN和ACK置1，确认号x+1，B的seq初始随机值y（不携带数据），进入SYN_RCVD状态；​A收到B确认后，返回确认，可携带数据（不携带不消耗序号），A进入ESTABLISHED状态​B收到确认后也进入ESTABLISHED状态
2. TCP建立连接时，初始序号（seq）为什么用随机值？
>- 目前对tcp会话的攻击主要分为两种中间人攻击和注入式攻击。前者是改变通讯双方的通信过程，接管整个tcp会话；后者是不改变通信双方的通信，只是在会话中插入一些伪装ip的Tcp包，这就要解决对接收序列号的预测这个技术难题，这个序列号预测也是最大的一个难点，所以从安全的角度来说，tcp序列号初始值越趋近于随机越好，算法越复杂越好。
3. 为什么是三次握手，而不是两次握手呢？
>- 防止A的请求报文在连接断开后失而复得，如果是两次握手，会导致B错误地单方面连接A。
#### 四次挥手释放连接
1. 挥手过程
>- 现在A和B都处于ESTABLISHED状态，A向其TCP发出连接释放报文段，FIN置1，主动关闭TCP连接。A进入FIN_WAIT1（终止等待1）状态。
>- B返回确认报文，B进入CLOSE_WAIT(关闭等待)状态。此时TCP处于半关闭状态(不在发送数据，但仍可以接收数据)，如果B仍要发送数据，A仍然接收。
>- A收到B的确认后，A就进入FIN_WAIT2（终止等待2）状态，等待B发出连接释放报文。 如果B已经没有向A发送的数据，则B发送请求释放报文，FIN置1，B进入LAST_ACK（最后确认）阶段，等待A的确认。
>- A在收到B的请求后，要发出确认报文，然后A进入TIME_WAIT（时间等待）状态。此时，连接还未释放，必须等待时间等待计时器设定的时间的2MSL后，A才进入CLOSED状态。

2. 为什么TIME-WAIT状态必须等待2MSL呢？
>- 为了保证A发送的最后一个ACK报文段能够到达B：因为这个ACK报文可能会丢失，所以处在LAST-ACK状态的B收不到最后的ACK报文，就回重传FIN+ACK的报文段。A就能在2MSL时间内收到这个重传的报文段，并重新发送ACK报文段，并重置定时器。
>- 使本连接产生的所有报文段从网络中消失，这样在下一个新的连接中不会出现这种旧的连接请求报文段。

3. 为什么建立连接是三次握手，而关闭连接是四次挥手？
>- 因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
>- 而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

#### TCP拥塞控制算法
1. 慢开始
> 当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。如图所示，每成功接收一次，就将cwnd扩大一倍
2. 拥塞避免
> 让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口cwnd按线性规律缓慢增长。无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。​
3. 快重传
> 首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。
4. 快恢复
> 当网络发生拥塞的时候，ssthresh将降为原来的一半，cwnd也降为一半，然后开始执行拥塞避免，而不是像慢开始一样，从1开始。

#### 流量控制算法
1. 停止等待协议SWP
2. 后退N帧协议GBN
3. 选择重传协议SR

#### UDP
1. UDP报文格式
> 8个字节的首部，对上层报文添加首部后交给IP层
2. 特点
>- UDP是无连接的，不需要建立连接，减少了开销和发送数据前的时延
>- UDP使用尽最大努力交付，不保证可靠交付，不需要维持复杂的连接状态
>- UDP么有拥塞控制
>- UDP支持一对一、一对多、多对一和多对多的相互通信
>- UDP首部开销8个字节

### 网络层/IP层协议
#### 地址解析协议ARP
>ARP 协议就是通过在主机的ARP的告诉缓存中存放一个IP地址到硬件地址的映射表，从而实现IP到硬件地址的解析。但需要注意的是，ARP协议解决的是同一个局域网上的主机或者路由器的IP地址到硬件地址的解析问题。
#### 网际控制报文协议ICMP
ICMP是为了更有效地转发IP数据报和提高交付成功的机会，允许主机或路由器报告差错情况和提供有关异常情况的报告数据。ICMP并不是高层协议，而是封装在IP数据报中，作为数据的一部分。
1. ICMP差错报告报文
>- 终点不可达：路由器或主机不能交付数据
>- 超时：路由器收到生存时间为0的数据报，丢弃报文并向源节点发送超时报文
>- 参数问题：收到的数据报首部字段不正确就丢弃报文，发送参数问题报文
>- 重定向：路由器将重定向的路由发给主机，更新其最优路径
2. ICMP询问报文
>- 回送请求和回答：PING命令，应用层直接使用网络层
>- 时间戳请求和回答

#### 网际组管理协议IGMP
> IGMP 在TCP/IP中负责局域网IP多播组成员管理的协议。

#### 路由选择协议
1. RIP：基于距离向量的路由选择协议
2. OSPF：基于链路状态的开放最短路径优先的路由协议。直接使用IP数据报传送