**目录**
   * [网络](#网络)
      * [1 三次握手](#1-三次握手)
      * [2 四次挥手](#2-四次挥手)
      * [3 ARP协议](#3-arp协议)
      * [4 urllib和urllib2的区别](#4-urllib和urllib2的区别)
      * [5 Post和Get](#5-post和get)
      * [6 Cookie和Session](#6-cookie和session)
      * [7 apache和nginx的区别](#7-apache和nginx的区别)
      * [8 网站用户密码保存](#8-网站用户密码保存)
      * [9 HTTP和HTTPS](#9-http和https)
      * [10 XSRF和XSS](#10-xsrf和xss)
      * [11 幂等 Idempotence](#11-幂等-idempotence)
      * [12 RESTful架构(SOAP,RPC)](#12-restful架构soaprpc)
      * [13 SOAP](#13-soap)
      * [14 RPC](#14-rpc)
      * [15 CGI和WSGI](#15-cgi和wsgi)
      * [16 中间人攻击](#16-中间人攻击)
      * [17 c10k问题](#17-c10k问题)
      * [18 socket](#18-socket)
      * [19 浏览器缓存](#19-浏览器缓存)
      * [20 HTTP1.0和HTTP1.1](#20-http10和http11)
      * [21 Ajax](#21-ajax)

# 网络
## 一、应用层

### HTTP协议
### 4 urllib和urllib2的区别

这个面试官确实问过,当时答的urllib2可以Post而urllib不可以.

1. urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。
2. urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。


### 5 Post和Get
[GET和POST有什么区别？及为什么网上的多数答案都是错的](http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html)
[知乎回答](https://www.zhihu.com/question/31640769?rf=37401322)

get: [RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1](http://tools.ietf.org/html/rfc2616#section-9.3)
post: [RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1](http://tools.ietf.org/html/rfc2616#section-9.5)



### 6 Cookie和Session

|      | Cookie                     | Session |
| :--- | :------------------------- | :------ |
| 储存位置 | 客户端                        | 服务器端    |
| 目的   | 跟踪会话，也可以保存用户偏好设置或者保存用户名密码等 | 跟踪会话    |
| 安全性  | 不安全                        | 安全      |

session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。

### 7 apache和nginx的区别

nginx 相对 apache 的优点：
* 轻量级，同样起web 服务，比apache 占用更少的内存及资源
* 抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能
* 配置简洁
* 高度模块化的设计，编写模块相对简单
* 社区活跃

apache 相对nginx 的优点：
* rewrite ，比nginx 的rewrite 强大
* 模块超多，基本想到的都可以找到
* 少bug ，nginx 的bug 相对较多
* 超稳定

### 8 网站用户密码保存

1. 明文保存
2. 明文hash后保存,如md5
3. MD5+Salt方式,这个salt可以随机
4. 知乎使用了Bcrypy(好像)加密

### 9 HTTP和HTTPS


| 状态码       | 定义               |
| :-------- | :--------------- |
| 1xx 报告    | 接收到请求，继续进程       |
| 2xx 成功    | 步骤成功接收，被理解，并被接受  |
| 3xx 重定向   | 为了完成请求,必须采取进一步措施 |
| 4xx 客户端出错 | 请求包括错的顺序或不能完成    |
| 5xx 服务器出错 | 服务器无法完成显然有效的请求   |

403: Forbidden
404: Not Found

HTTPS握手,对称加密,非对称加密,TLS/SSL,RSA


### 11 幂等 Idempotence

HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的**副作用**。(注意是副作用)

`GET http://www.bank.com/account/123456`，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。`GET http://www.news.com/latest-news`这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。

DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：`DELETE http://www.forum.com/article/4231`，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。


POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：`POST http://www.forum.com/articles`的语义是在`http://www.forum.com/articles`下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。

PUT所对应的URI是要创建或更新的资源本身。比如：`PUT http://www.forum/articles/4231`的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。


### 12 RESTful架构(SOAP,RPC)

推荐: http://www.ruanyifeng.com/blog/2011/09/restful.html


### 13 SOAP

SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。

### 14 RPC

RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。

总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap.当互联网时代,臃肿SOA被简化为http+xml/json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了.

进化的顺序: RPC -> SOAP -> RESTful

### 15 CGI和WSGI
CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。
CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。

WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。

官方说明：[PEP-3333](https://www.python.org/dev/peps/pep-3333/)

### 16 中间人攻击

在GFW里屡见不鲜的,呵呵.

中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。

### 17 c10k问题

所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。
推荐: https://my.oschina.net/xianggao/blog/664275



### 19 浏览器缓存

推荐: http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html

304 Not Modified

### 20 HTTP1.0和HTTP1.1

推荐: http://blog.csdn.net/elifefly/article/details/3964766

1. 请求头Host字段,一个服务器多个网站
2. 长链接
3. 文件断点续传
4. 身份认证,状态管理,Cache缓存

HTTP请求8种方法介绍 
HTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。

GET

GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。

GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。

HEAD

HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。

POST

POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。

PUT

PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。

DELETE

DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。

CONNECT

CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。

OPTIONS

OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许

TRACE

TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。

HTTP/1.1之后增加的方法

在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：

PATCH

PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：

但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。 
当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。

### 21 Ajax
AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。


## 二、传输层
### TCP和UDP的区别
- TCP通过拥塞控制、超时重传、确认机制等机制是可靠连接，UDP是不可靠的； 
- TCP面向字节流，UDP面向报文； 
- TCP是面向连接的，所以实现的是一对一通信，UPD是无连接的，所以可以实现一对多、多对多的通信；​ 
- TCP场景：电子邮件，远程终端接入，文件传输；UDP场景：DNS，TFTP，RIP，DHCP，流媒体通信

### TCP协议
### socket

硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP和TCP的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到IP层交上来的运输层报文时，就能够根据其首部中的目的端口号把数据交付应用层的目的应用层。

运输层用一个**16位端口号**标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由TCP和UDP来完成。

运输层的端口号分为服务器端使用的端口号（0~1023指派给熟知端口，1024~49151是登记端口号）和客户端暂时使用的端口号（49152~65535）

**TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP地址：端口号）来表示。每一条TCP连接唯一被通信两端的两个端点所确定。**

Socket=Ip address+ TCP/UDP + port

### TCP报文格式
源端口和目的端口各占16位，Seq序号占32位，ACK确认号占32位，首部长度，保留位，标志位，窗口，校验和，紧急指针
- Seq序号，占32位，用来标识从TCP源端向目的端口发送的字节流，发起方发送数据时对此进行标记。
- ACK确认号，占32位，只有ACK标志位为1时才有效，Ack=Seq+1
- 标志位：共6个，URG，ACK，PSH，RST（重置连接），SYN（发起连接），FIN（结束连接），在三次握手中出现
 
### 三次握手建立连接
#### 连接过程
1. A请求连接，SYN置1，seq初始随机值x（不携带数据），进入SYN_SENT状态；​
2. B收到请求，回复确认报文，SYN和ACK置1，确认号x+1，B的seq初始随机值y（不携带数据），进入SYN_RCVD状态；
3. A收到B确认后，返回确认，可携带数据（不携带不消耗序号），A进入ESTABLISHED状态
4. ​B收到确认后也进入ESTABLISHED状态

#### TCP建立连接时，初始序号（seq）为什么用随机值？
目前对tcp会话的攻击主要分为两种中间人攻击和注入式攻击。前者是改变通讯双方的通信过程，接管整个tcp会话；后者是不改变通信双方的通信，只是在会话中插入一些伪装ip的Tcp包，这就要解决对接收序列号的预测这个技术难题，这个序列号预测也是最大的一个难点，所以从安全的角度来说，tcp序列号初始值越趋近于随机越好，算法越复杂越好。

#### 为什么是三次握手，而不是两次握手呢？
防止A的请求报文在连接断开后失而复得，如果是两次握手，会导致B错误地单方面连接A。
#### 最后一次ACK没有送达会怎么样？
如果此时ACK在网络中丢失，那么Server端该TCP连接的状态为SYN_RECV，并且依次等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包，以便Client重新发送ACK包。Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5。

如果重发指定次数后，仍然未收到ACK应答，那么一段时间后，Server自动关闭这个连接。但是Client认为这个连接已经建立，**如果Client端向Server写数据，Server端将以RST包响应**，方能感知到Server的错误。

 

### 四次挥手释放连接
#### 挥手过程
1. 现在A和B都处于ESTABLISHED状态，A向其TCP发出连接释放报文段，FIN置1，主动关闭TCP连接。A进入FIN_WAIT1（终止等待1）状态。
2. B返回确认报文，B进入CLOSE_WAIT(关闭等待)状态。此时TCP处于半关闭状态(不在发送数据，但仍可以接收数据)，如果B仍要发送数据，A仍然接收。
3. A收到B的确认后，A就进入FIN_WAIT2（终止等待2）状态，等待B发出连接释放报文。 如果B已经没有向A发送的数据，则B发送请求释放报文，FIN置1，B进入LAST_ACK（最后确认）阶段，等待A的确认。
4. A在收到B的请求后，要发出确认报文，然后A进入TIME_WAIT（时间等待）状态。此时，连接还未释放，必须等待时间等待计时器设定的时间的2MSL后，A才进入CLOSED状态。
为什么TIME-WAIT状态必须等待2MSL呢？
1. 为了保证A发送的最后一个ACK报文段能够到达B：因为这个ACK报文可能会丢失，所以处在LAST-ACK状态的B收不到最后的ACK报文，就回重传FIN+ACK的报文段。A就能在2MSL时间内收到这个重传的报文段，并重新发送ACK报文段，并重置定时器。
2. 使本连接产生的所有报文段从网络中消失，这样在下一个新的连接中不会出现这种旧的连接请求报文段。

#### 为什么TIME-WAIT状态必须等待2MSL呢？
1. 为了保证A发送的最后一个ACK报文段能够到达B：因为这个ACK报文可能会丢失，所以处在LAST-ACK状态的B收不到最后的ACK报文，就回重传FIN+ACK的报文段。A就能在2MSL时间内收到这个重传的报文段，并重新发送ACK报文段，并重置定时器。
2. 使本连接产生的所有报文段从网络中消失，这样在下一个新的连接中不会出现这种旧的连接请求报文段。
 
#### 为什么建立连接是三次握手，而关闭连接是四次挥手？
因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

### 流量控制算法
流量控制针对的是发送方和接收方发送和接受速率不匹配的问题。接收方告知发送发自己的接收能力，假设网络无限好。
#### 停止等待协议SWP
发一个分组等待对方的ACK回应后继续发送。
#### 滑动窗口
接收方在一个窗口都满了以后发送ACK确认并要求发送下一个窗口
#### 后退N帧协议GBN
表示接受前N-1个分组失败，由发送方退回到N步继续发送
#### 选择重传协议SR
引入序列号，发送超时未收到的序列号分组
 

### TCP拥塞控制算法
发送方感知网络的拥塞情况，假设接收方缓冲区和接收窗口无限大
### 发生超时情况
#### 慢开始
当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。每成功接收一次，就将cwnd扩大一倍（每收到一个ACK窗口增加1）达到慢开始门限ssthresh时，使用拥塞避免方式加法增大窗口。
#### 拥塞避免
让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口cwnd按线性规律缓慢增长。

无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。​
### 收到重复确认情况
#### 快重传
当发送方连续收到重复确认时，首先要求接收方每收到一个失序的报文段后就立即发出未失序的最后分组对应的确认号（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。
#### 快恢复
当网络发生拥塞的时候（失序报文重复ACK分组），ssthresh将降为原来的一半，cwnd也降为一半，然后开始执行拥塞避免，而不是像慢开始一样，从1开始。
 
### UDP
### UDP报文格式
8个字节的首部，对上层报文添加首部后交给IP层
### 特点
- UDP是无连接的，不需要建立连接，减少了开销和发送数据前的时延
- UDP使用尽最大努力交付，不保证可靠交付，不需要维持复杂的连接状态
- UDP么有拥塞控制
- UDP支持一对一、一对多、多对一和多对多的相互通信
- UDP首部开销8个字节
 

## 三、网络层
### 3 ARP协议

地址解析协议(Address Resolution Protocol)，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，以保证通信的顺利进行。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。

## 四、数据链路层

## 五、网络接口层






