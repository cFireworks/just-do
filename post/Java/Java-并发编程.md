## Java并发编程

### 目录
* [线程管理](./Java并发编程.md#JC.01)
* [线程同步基础](./Java并发编程.md#JC.02)
* [线程同步工具](./Java并发编程.md#JC.03)
* [线程执行器](./Java并发编程.md#JC.04)


### <a name="JC.01">一、线程管理</a>
### 1.0 线程与进程
进程是执行期的程序以及相关资源的总称，通常包含执行代码、打开的文件、挂起的信号、内核内部数据、处理器状态、一个或多个具有内存映射的地址空间以及一个或多个执行线程，还有存放全局变量的数据段。

**线程是在进程中活动的对象，每个线程都拥有一个独立的程序计数器、进程栈和一组寄存器。**内核调度的对象是线程，而不是进程。

在Linux中，线程是一种特殊的进程，它与其他进程共享某些资源：
```c
// Linux通过clone()系统调用实现复制父进程以创建新进程
// 线程的创建，在调用clone()时需传递一些参数标志来指明共享资源
clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)
```
### 1.1 线程创建
1. 直接继承`Thread`类，重写`run()`方法。
2. 构建一个实现`Runable()`接口的类，重写`run()`方法，以该类创建的实例作为构造参数创建`Thread`类对象。
### 1.2 控制线程中断
1. 线程中断：Java中的一种机制来向线程表明想要终止它，线程对象检查中断请求并决定是否响应中断请求。
2. 中断检测：Java提供`InterruptedException`异常，线程在执行中断`task.interrupt()`后将抛出该异常，`run()`方法可以捕获该异常。
### 1.3 线程的状态
Java线程在运行的生命周期中可能处于6种不同的状态，分别是`NEW`, `RUNNABLE`, `BLOCKED`, `WAITING`, `TIME_WAITING`, `TERMINATED`.
| 状态名称 | 说明 | 进入方式 |
|:-:|:--:|:--:|
| NEW | 初始状态，线程被构建，但还没有调用start()方法 | 创建线程未启动 |
|  RUNNING| 运行状态，对应于操作系统中的就绪和运行状态 | start之后 |
|  BLOCKED| 阻塞状态，表示线程阻塞于锁，等待锁 | 程序等待进入同步区域时 |
|  WAITING| 等待状态，表示当前线程需要等待其他线程的通知或中断 | `Object::wait()`,`Thread::join()`, `LockSupport::park()` |
|  TIMED_WAITING| 超时等待状态，可以在指定时间自行返回 | `Thread::sleep()` ,`Object::wait(timeout)`, `Thread::join(timeout)`, `LockSupport::parkNanos()`, `LockSupport::parkUntil()` |
|  TERMINATED| 终止状态，表示当前线程已经执行完毕 | 线程执行结束 |

1. 休眠：`thread.sleep()`或者`TimeUnit.SECONDS.sleep()`
2. 等待线程结束：`thread.join()`,发起线程等待thread线程执行结束。
3. 守护线程：`thread.setDaemon()`，只能在`start()`方法前调用，一旦线程开始，daemon状态不可改变。此时调用`setDaemon()`，将抛出`IllegalThreadStateException`异常。
> #### `wait()` 和 `sleep()` 的区别？
> - `wait()`方法是属于`Object`类的方法，能够实现将持有锁的线程由`RUNNING`状态变为`WAITING`状态或者`TIMED_WAITING`状态。持有锁的线程在执行`wait()`后，会将当前线程仿佛等待队列，并释放锁，当另一个持有该锁的线程使用`notify()`或`notifyAll()`唤醒该线程时，该线程会进入同步队列，等待重新获取锁。对象锁是依靠`sychronized`关键词实现的，底层是获取对象的`monitor`监视器，对应于一个`ObjectMonitor`对象，其中有`EntryList`和`WaitSet`两个列表，当线程调用`wait()`之后，`ObjectMonitor`对象会将该线程加入到`WaitSet`中，直到另一个线程唤醒，则该线程有机会从`WaitSet`中移除，加入到`EntryList`中，等待获取`monitor`。`notify()`方法不会释放锁。
> - `sleep()`方法是属于`Thread`类的方法，能够将当前线程挂起并进入到`TIMED_WAITING`状态，但是并不会释放该线程占有的锁，当时间结束定时器会触发，内核收到中断后会修改其运行状态，进入`RUNNING`状态。
> 1. `sleep()`是线程的静态方法，而`wait()`是`Object`类的方法
> 2. `sleep()`方法不会释放锁，而`wait()`方法只能在同步方法或同步块中使用
> 3. `sleep()`方法必须捕获异常，`wait()`方法、`notify()`方法和`notifyAll()`方法不需要捕获异常

### <a name="JC.02">二、线程同步基础</a>
### 2.1 方法同步
1. **竞态条件**：多个线程同时访问一个共享资源时，竞态条件随之产生。
2. **临界区**：一个用于访问共享资源的代码块，并且同一时刻只能由一个线程执行。
3. **两种基本同步机制**：*关键词synchronized* 和 *Lock接口及其实现类*

### 2.2 关键词synchronized
> #### `synchronized`通过进入和退出Monitor对象来实现方法同步和代码块同步，
> - 代码块同步是使用`monitorenter`和`monitorexit`指令实现的
> - 而方法同步是通过设置该方法表中的`ACC_SYNCHRONIZED`标志，如果执行到有该标志的方法，则尝试获取monitor对象，成功则正常执行，否则进入阻塞状态等待monitor对象被释放。
> #### 锁的升级与对比
> 虚拟机为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁。锁一共有4种状态，分别是`无锁状态`、`偏向锁状态`、`轻量级锁状态`和`重量级锁状态`。锁可以升级但不可以降级。
> - 无锁状态：无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功，使用CAS机制实现无锁状态。
> - 偏向锁状态：偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。线程在进入同步块代码获取锁时会在Mark Word里存储锁偏向的线程id，在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word是否存储指向该线程的偏向锁，保证了在只有一个线程时减少CAS指令和锁的获取释放。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点，它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，如果线程不处于活动状态，撤销偏向锁后恢复到无锁（标志位为“01”），否则升级为轻量级锁（标志位为“00”）的状态。
> - 轻量级锁状态：当锁是偏向锁的时候，被另外的线程所访问出现竞争时，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。
> - 重量级锁：在轻量级锁状态下，如果只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

1. **修饰一个方法：** 此时synchronized绑定的对象是对象实例本身，隐式绑定。
2. **修饰静态方法：** 此时synchronized绑定的对象是该类对象，而非类对象的实例。
3. **修饰代码块：** 绑定一个普通对象实例。
4. **同步代码块中使用条件：** 基于Object类上提供的wait()让线程进入休眠状态，notify()和notifyAll()唤醒休眠状态的线程。

### CAS操作
> CAS操作，全称比较并交换(Compare and Swap)，CAS操作需要输入两个数值，一个旧值-操作前的值，和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化才交换新值，发生了变化则不交换。
> 
> JVM中的CAS操作利用了处理器提供的CMPXCHG指令实现，这样的指令在处理器层面提供总线锁定或缓存锁定机制，使得内存操作具有原子性，当多个线程试图访问一段内存，通过缓存锁或者总线锁使得同时只有一个线程操作能对共享内存进行修改，其他线程能够读到该线程对内存的更改。
>
> CAS实现原子操作存在三个问题：ABA问题，循环时间长开销大，只能保证一个共享变量的原子操作
> - ABA问题是，一个值原来是A，变成B后又变成A，使用CAS进行检查时会发现它的值没有发生变化，但实际发生变化。解决ABA问题可以使用版本号，在变量前面追加上版本号，每次变量更新把版本号加1，ABA就会变成1A2B3A,Atomic包中提供AtomicStampedReference类来解决ABA问题。
> - 循环时间长开销大问题，自选CAS如果长时间不成功，会给CPU带来非常大的执行开销。
> - 只能保证一个共享变量的原子操作问题，当对一个共享变量操作时可以使用循环CAS保证原子操作，JDK中AtomicReference类可以保证引用对象间的原子性。

### volatile的原理及应用
> volatile是轻量级的同步，在多处理器开发中保证了共享变量的可见性，当一个线程修改一个共享变量时，其他线程能读到这个修改的值。
> - 原理：volatile修饰的共享变量在进行写操作时会多一条Lock前缀，**Lock前缀指令在多核处理器中将当前处理器缓存行的数据写回系统内存**，称为缓存锁定，**并将其他CPU里缓存了该内存地址的数据无效，称为缓存失效**，根据缓存一致性协议，每个处理器会嗅探总线上传播的数据是否与缓存一致，若缓存行对应数据被修改，则缓存失效。
> - volatile与线程安全：volatile只能保证线程之间操作的可见性和有序性，在复杂场景中并不具有原子性的特点，因此不是绝对线程安全的。在变量需要和其他状态变量共同参与同步约束的情况下，还是得使用synchronized、锁或者原子类来实现线程同步。

### 2.3 锁机制
`java.util.concurrent.locks`中定义的`Lock机制`比`synchronized机制`更加强大和灵活。synchronized仅能作用在一段结构化代码中，Lock接口可以适应更复杂的代码结构。具有`tryLock()`方法、`ReadWriteLock接口`等，提供新特性。性能更优越。
1. `ReentrantLock类`：
2. `ReadWriteLock接口`及其实现`类ReentrantReadWriteLock`：
3. `StampedLock类`:
4. `Semaphore`：是一个计数器，用来控制一个或多个共享资源的访问。
5. `CountDownLatch`：可以使一个线程等待多个操作结束。
6. `CyclicBarrier`：可以使多个线程在一个共同状态点同步。
7. `Phaser`：可以分阶段地控制并发任务的执行。只有所有的线程都完成一个阶段后，才能继续下一个阶段。
8. `Exchanger`：能够使得两个线程在某个点进行数据交换。
9. `CompletableFuture`：一个或多个任务等待另外一些任务执行结束，并且这些任务将以异步方式运行。

### 2.4 比较Synchronized，ReentrantLock
> ### Lock和synchronized的区别
> Lock与提供了与synchronized关键字类似的同步功能，只是在使用时要显示地获取和释放锁，拥有锁获取与释放的可操作性、可中断地获取锁以及超时获取锁等同步特性。
> - Lock能使线程尝试非阻塞地获取锁，当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁
> - Lock能使线程被中断地获取锁，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常会抛出，锁被释放
> - Lock能使线程超时获取锁，在指定的截止时间之前获取锁，如果截止时间到了仍未获取锁则返货

> ### 抽象队列同步器AbstractQueuedSynchronizer（AQS）
> 抽象同步队列是一个抽象类，是用来构建锁或者其他同步组件的基本框架，核心是使用一个volatile修饰的int变量来标识同步状态，通过一个内置的FIFO队列来完成尝试获取锁的线程的排队工作。通过重写抽象队列同步器的指定方法如tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared等可以设计不同的同步器。
> 
> 同步器提供的模板方法基本分为3类，独占式获取与释放同步状态、共享式获取与释放同步状态和查询同步队列中的等待线程。
> 
> 同步器完成线程同步主要包括同步队列、独占式、共享式、超时同步状态获取与释放的数据结构和模板方法。
>
> 同步队列：是一个帮助同步状态管理的FIFO双向队列，队列的节点包含获取同步状态失败的线程的引用、等待状态以及前驱后继节点。当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点，并将其加入同步队列，同时会阻塞当前线程，同步状态释放后，会将首节点的线程唤醒，使其再次尝试获取同步状态。
> 
> 独占式同步状态获取释放：获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋，移出队列的条件是前驱节点为头结点且获得同步状态。在释放同步状态时，同步器调用tryRelease方法释放同步状态，唤醒头结点的后继节点。
>
> 共享式同步状态获取释放：共享式获取与独占式获取区别在于同一时刻能否有多个线程同时获取到同步状态。
> 
> 独占式超时获取同步状态：调用doAcquireNanos(int arg, long nanosTimeout)方法可以超时获取同步状态。

### 背景，应该就是`Synchronized`的缺点
* `Synchronized`产生原因，`原子性(Atomicity)`与`可见性(visibility)`，其中可见性涉及到`JMM`的`happens-before`原语，这又涉及到`Memory Barrier`，推荐这篇文章[《并发导论》][1]

* `Synchronized`使用示例

	```java
    synchronized (lockObject) {
		// update object state
	}
	```

* 但是`Synchronized`存在的缺点是：它无法中断一个正在等候获得锁的线程，也无法通过投票得到锁...同时多个线程争用同一个锁，jvm的总体开销有点大

### `ReentrantLock`
* 默认是不公平(`unfair`)锁
* 有一个与锁相关的`获取计数器`，获取一次加一，获取两次加二，注意释放两次才代表真正释放锁

* `ReentrantLock`使用示例

	```java
    ReentrantLock lock = new ReentrantLock();
    lock.lock();
    try {
    	// update object state
    }
    finally {
    	lock.unlock();
    }
	```

* 相比较`Synchronized`，`ReentrantLock`在调度的开支上花的时间相对少，从而为更高的吞吐率留下空间，实现了更有效的CPU利用

### `Condition`
* 对比`JDK 1.4`以前版本中的`Object.wait()`，`Object.notify()`，`Object.notifyAll()`，上述三种线程间同步方式有问题，可问题是什么，需要继续学习，留在`todolist`...

* `Condition`提供`await()`，`signal()`，`signalAll()`用于实现上述功能

* `Condition`使用示例，需要和`ReentrantLock`配合，简单使用参见[《关于JAVA Condition 条件变量》][3]
	```java
    ReentrantLock lock = new ReentrantLock();
    Condition condition = lock.newCondition();
    lock.lock();
    try {
    	condition.await();
    	// update object state
    }
    finally {
    	lock.unlock();
    }
    
    condition.signal();
    condition.signalAll();
    ```
### 那么在什么时候使用`ReentrantLock`
* 需要实现`时间锁等候`，`可中断锁等候`，`无块结构锁`，`多个条件变量`，`锁投票`，`高度争用`的情形