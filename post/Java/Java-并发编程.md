## Java并发编程

### 目录
* [Java内存模型](./Java并发编程.md#JC.00)
* [线程管理](./Java并发编程.md#JC.01)
* [线程同步基础](./Java并发编程.md#JC.02)
* [Java中的线程池](./Java并发编程.md#JC.03)
* [线程执行器](./Java并发编程.md#JC.04)

### <a name="JC.00">Java内存模型</a>
### 0.1 Java内存模型的抽象结构
> Java线程之间的通信由Java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：
> - 主内存：存储线程之间的共享变量
> - 工作内存（本地内存）：每个线程都已一个私有的工作内存，存储了线程使用的共享变量的副本

### 0.2 内存之间的交互操作
> 主内存与工作内存之间通过Java定义的8种内存操作来完成，实现一个变量从主内存拷贝到工作内存，再从工作内存同步回主内存的过程。8种操作如下：
> - `lock`:作用于主内存变量，将变量标示为一条线程独占的状态
> - `unlock`:作用于主内存变量，把变量从锁定状态释放出来
> - `read`:作用于主内存变量，把一个变量从主内存传输到一个线程的工作内存中，让load使用
> - `load`:作用于工作内存的变量，把read操作从主内存中获得的变量值放到工作内存中的变量副本中
> - `use`:作用于工作内存的变量，把工作内存的变量值传递给执行引擎
> - `assign`:作用于工作内存中的变量，把一个从执行引擎接收的值赋给工作内存的变量
> - `store`:作用于工作内存的变量，将一个变量值从工作内存传递给主内存，供write使用
> - `write`:作用于主内存的变量，把store从工作内存得到的变量值放入主内存的变量中

### <a name="JC.01">一、线程管理</a>
### 1.0 线程与进程
进程是执行期的程序以及相关资源的总称，通常包含执行代码、打开的文件、挂起的信号、内核内部数据、处理器状态、一个或多个具有内存映射的地址空间以及一个或多个执行线程，还有存放全局变量的数据段。

**线程是在进程中活动的对象，每个线程都拥有一个独立的程序计数器、线程栈和一组寄存器。** 内核调度的对象是线程，而不是进程。

Java的线程是直接映射到一个操作系统原生线程来实现的，中间没有额外的间接结构。在Linux中，线程是一种特殊的进程，它与其他进程共享某些资源：
```c
// Linux通过clone()系统调用实现复制父进程以创建新进程
// 线程的创建，在调用clone()时需传递一些参数标志来指明共享资源
clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)
```
### 1.1 线程创建
1. 直接继承`Thread`类，重写`run()`方法。
2. 构建一个实现`Runable()`接口的类，重写`run()`方法，以该类创建的实例作为构造参数创建`Thread`类对象。
3. 实现Callable接口，结合 FutureTask使用
4. 利用该线程池ExecutorService、Callable、Future来实现

创建线程可以设置线程的优先级，范围是0-10，还可以给线程设置名称，调用setDemon方法可以设置线程为守护线程，当程序中仅剩守护线程在运行时，会先结束这些线程再结束程序。
### 1.2 控制线程中断
1. 线程中断：Java中的一种机制来向线程表明想要终止它，线程对象检查中断请求并决定是否响应中断请求。
2. 中断检测：Java提供`InterruptedException`异常，线程在执行中断`task.interrupt()`后将抛出该异常，`run()`方法可以捕获该异常。
### 1.3 线程的休眠与唤醒
Thread类的sleep()方法可以使线程休眠,如果线程持有对象锁，可以通过锁对象的wait()和notify()/notifyAll()来控制线程的挂起和恢复。
### 1.4 等待线程结束
使用join()方法可以等待线程结束后再执行其他任务。
### 1.5 线程的状态
Java线程在运行的生命周期中可能处于6种不同的状态，分别是`NEW`, `RUNNABLE`, `BLOCKED`, `WAITING`, `TIME_WAITING`, `TERMINATED`.
| 状态名称 | 说明 | 进入方式 |
|:-:|:--:|:--:|
| NEW | 初始状态，线程被构建，但还没有调用start()方法 | 创建线程未启动 |
|  RUNNING| 运行状态，对应于操作系统中的就绪和运行状态 | start之后 |
|  BLOCKED| 阻塞状态，表示线程阻塞于锁，等待锁 | 程序等待进入同步区域时 |
|  WAITING| 等待状态，表示当前线程需要等待其他线程的通知或中断 | `Object::wait()`,`Thread::join()`, `LockSupport::park()` |
|  TIMED_WAITING| 超时等待状态，可以在指定时间自行返回 | `Thread::sleep()` ,`Object::wait(timeout)`, `Thread::join(timeout)`, `LockSupport::parkNanos()`, `LockSupport::parkUntil()` |
|  TERMINATED| 终止状态，表示当前线程已经执行完毕 | 线程执行结束 |

1. 休眠：`thread.sleep()`或者`TimeUnit.SECONDS.sleep()`
2. 等待线程结束：`thread.join()`,发起线程等待thread线程执行结束。
3. 守护线程：`thread.setDaemon()`，只能在`start()`方法前调用，一旦线程开始，daemon状态不可改变。此时调用`setDaemon()`，将抛出`IllegalThreadStateException`异常。
> #### `wait()` 和 `sleep()` 的区别？
> - `wait()`方法是属于`Object`类的方法，能够实现将持有锁的线程由`RUNNING`状态变为`WAITING`状态或者`TIMED_WAITING`状态。持有锁的线程在执行`wait()`后，会将当前线程仿佛等待队列，并释放锁，当另一个持有该锁的线程使用`notify()`或`notifyAll()`唤醒该线程时，该线程会进入同步队列，等待重新获取锁。对象锁是依靠`sychronized`关键词实现的，底层是获取对象的`monitor`监视器，对应于一个`ObjectMonitor`对象，其中有`EntryList`和`WaitSet`两个列表，当线程调用`wait()`之后，`ObjectMonitor`对象会将该线程加入到`WaitSet`中，直到另一个线程唤醒，则该线程有机会从`WaitSet`中移除，加入到`EntryList`中，等待获取`monitor`。`notify()`方法不会释放锁。
> - `sleep()`方法是属于`Thread`类的方法，能够将当前线程挂起并进入到`TIMED_WAITING`状态，但是并不会释放该线程占有的锁，当时间结束定时器会触发，内核收到中断后会修改其运行状态，进入`RUNNING`状态。
> 1. `sleep()`是线程的静态方法，而`wait()`是`Object`类的方法
> 2. `sleep()`方法不会释放锁，而`wait()`方法只能在同步方法或同步块中使用
> 3. `sleep()`方法必须捕获异常，`wait()`方法、`notify()`方法和`notifyAll()`方法不需要捕获异常

### 1.6 线程的切换
> 引起线程上下文切换的原因，主要存在三种情况如下：
> 1. 中断处理：在中断处理中，其他程序”打断”了当前正在运行的程序。当CPU接收到中断请求时，会在正在运行的程序和发起中断请求的程序之间进行一次上下文切换。中断分为硬件中断和软件中断，软件中断包括因为IO阻塞、未抢到资源或者用户代码等原因，线程被挂起。
> 2. 多任务处理：在多任务处理中，CPU会在不同程序之间来回切换，每个程序都有相应的处理时间片，CPU在两个时间片的间隔中进行上下文切换。
> 3. 用户态切换：对于一些操作系统，当进行用户态切换时也会进行一次上下文切换，虽然这不是必须的。
> 
> 对于我们经常 使用的抢占式操作系统 而言，引起线程上下文切换的原因大概有以下几种：
> - 当前执行任务的时间片用完之后，系统CPU正常调度下一个任务；
> - 当前执行任务碰到IO阻塞，调度器将此任务挂起，继续下一任务；
> - 多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；
> - 用户代码挂起当前任务，让出CPU时间；
> - 硬件中断；
> 
> 上下文切换（有时也称做进程切换或任务切换）是指CPU从一个进程或线程切换到另一个进程或线程。
> - 进程（有时候也称做任务）是指一个程序运行的实例。
> - 在Linux系统中，线程 就是能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的 轻量级的进程。
> - 上下文 是指某一时间点 CPU 寄存器和程序计数器的内容。
> - 寄存器 是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。
> - 程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。
>
> 上下文切换过程
> - PCB通常是系统内存占用区中的一个连续存区，它存放着操作系统用于描述进程情况及控制进程运行所需的全部信息，它使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位或一个能与其他进程并发执行的进程。
> 1. 保存进程A的状态（寄存器和操作系统数据）；
> 2. 更新PCB中的信息，对进程A的“运行态”做出相应更改；
> 3. 将进程A的PCB放入相关状态的队列；
> 4. 将进程B的PCB信息改为“运行态”，并执行进程B；
> 5. B执行完后，从队列中取出进程A的PCB，恢复进程A被切换时的上下文，继续执行A；
>
> 上下文切换消耗: 上下文切换会带来 直接和间接 两种因素影响程序性能的消耗。
> - 直接消耗：指的是CPU寄存器需要保存和加载, 系统调度器的代码需要执行, TLB实例需要重新加载, CPU 的pipeline需要刷掉；
> - 间接消耗：指的是多核的cache之间得共享数据, 间接消耗对于程序的影响要看线程工作区操作数据的大小；
>
> 减少上下文切换
> 1. 既然上下文切换会导致额外的开销，因此减少上下文切换次数便可以提高多线程程序的运行效率。但上下文切换又分为2种：
> - 让步式上下文切换：指执行线程主动释放CPU，与锁竞争严重程度成正比，可通过减少锁竞争来避免；
> - 抢占式上下文切换：指线程因分配的时间片用尽而被迫放弃CPU或者被其他优先级更高的线程所抢占，一般由于线程数大于CPU可用核心数引起，可通过调整线程数，适当减少线程数来避免。
> 2. 所以，减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。
> - 无锁并发：多线程竞争时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash取模分段，不同的线程处理不同段的数据；
> - CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需要加锁；
> - 最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态；
> - 使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换；

### 1.7 ThreadLocal
ThreadLocal是一个关于创建线程局部变量的类。

通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。通过set()和get()方法可以使用ThreadLocal。

下面是ThreadLocal的set方法实现过程，大致为
- 首先获取当前线程
- 利用当前线程作为句柄获取一个ThreadLocalMap的对象
- 如果上述ThreadLocalMap对象不为空，则设置值，否则创建这个ThreadLocalMap对象并设置值

使用InheritableThreadLocal可以实现多个线程访问ThreadLocal的值，通过从父进程复制其InheritableThreadLocal来实现值传递。

使用场景
- 实现单个线程单例以及单个线程上下文信息存储，比如交易id等
- 实现线程安全，非线程安全的对象使用ThreadLocal之后就会变得线程安全，因为每个线程都会有一个对应的实例
- 承载一些线程相关的数据，避免在方法中来回传递参数





### <a name="JC.02">二、线程同步基础</a>
### 2.1 方法同步
1. **竞态条件**：多个线程同时访问一个共享资源时，竞态条件随之产生。
2. **临界区**：一个用于访问共享资源的代码块，并且同一时刻只能由一个线程执行。
3. **两种基本同步机制**：*关键词synchronized* 和 *Lock接口及其实现类*

### 2.2 关键词synchronized
> #### `synchronized`通过进入和退出Monitor对象来实现方法同步和代码块同步，
> - 代码块同步是使用`monitorenter`和`monitorexit`指令实现的
> - 而方法同步是通过设置该方法表中的`ACC_SYNCHRONIZED`标志，如果执行到有该标志的方法，则尝试获取monitor对象，成功则正常执行，否则进入阻塞状态等待monitor对象被释放。
> #### 锁的升级与对比
> 虚拟机为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁。锁一共有4种状态，分别是`无锁状态`、`偏向锁状态`、`轻量级锁状态`和`重量级锁状态`。锁可以升级但不可以降级。
> - 无锁状态：无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功，使用CAS机制实现无锁状态。
> - 偏向锁状态：偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。线程在进入同步块代码获取锁时会在Mark Word里存储锁偏向的线程id，在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word是否存储指向该线程的偏向锁，保证了在只有一个线程时减少CAS指令和锁的获取释放。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点，它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，如果线程不处于活动状态，撤销偏向锁后恢复到无锁（标志位为“01”），否则升级为轻量级锁（标志位为“00”）的状态。
> - 轻量级锁状态：当锁是偏向锁的时候，被另外的线程所访问出现竞争时，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。
> - 重量级锁：在轻量级锁状态下，如果只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数(JVM虚拟机提供了-XX:+UseSpinning参数来开启自旋锁，使用-XX:PreBlockSpin参数来设置自旋锁的等待次数)，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

1. **修饰一个方法：** 此时synchronized绑定的对象是对象实例本身，隐式绑定。
2. **修饰静态方法：** 此时synchronized绑定的对象是该类对象，而非类对象的实例。
3. **修饰代码块：** 绑定一个普通对象实例。
4. **同步代码块中使用条件：** 基于Object类上提供的wait()让线程进入休眠状态，notify()和notifyAll()唤醒休眠状态的线程。

### CAS操作
> CAS操作，全称比较并交换(Compare and Swap)，CAS操作需要输入两个数值，一个旧值-操作前的值，和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化才交换新值，发生了变化则不交换。
> 
> JVM中的CAS操作利用了处理器提供的CMPXCHG指令实现，这样的指令在处理器层面提供总线锁定或缓存锁定机制，使得内存操作具有原子性，当多个线程试图访问一段内存，通过缓存锁或者总线锁使得同时只有一个线程操作能对共享内存进行修改，其他线程能够读到该线程对内存的更改。
>
> CAS实现原子操作存在三个问题：ABA问题，循环时间长开销大，只能保证一个共享变量的原子操作
> - ABA问题是，一个值原来是A，变成B后又变成A，使用CAS进行检查时会发现它的值没有发生变化，但实际发生变化。解决ABA问题可以使用版本号，在变量前面追加上版本号，每次变量更新把版本号加1，ABA就会变成1A2B3A,Atomic包中提供AtomicStampedReference类来解决ABA问题。
> - 循环时间长开销大问题，自选CAS如果长时间不成功，会给CPU带来非常大的执行开销。
> - 只能保证一个共享变量的原子操作问题，当对一个共享变量操作时可以使用循环CAS保证原子操作，JDK中AtomicReference类可以保证引用对象间的原子性。

### volatile的原理及应用
> volatile是轻量级的同步，在多处理器开发中保证了共享变量的可见性，当一个线程修改一个共享变量时，其他线程能读到这个修改的值。
> - 原理：volatile修饰的共享变量在进行写操作时会多一条Lock前缀，**Lock前缀指令在多核处理器中将当前处理器缓存行的数据写回系统内存**，称为缓存锁定，**并将其他CPU里缓存了该内存地址的数据无效，称为缓存失效**，根据缓存一致性协议，每个处理器会嗅探总线上传播的数据是否与缓存一致，若缓存行对应数据被修改，则缓存失效。
> - volatile与线程安全：volatile只能保证线程之间操作的可见性和有序性，在复杂场景中并不具有原子性的特点，因此不是绝对线程安全的。在变量需要和其他状态变量共同参与同步约束的情况下，还是得使用synchronized、锁或者原子类来实现线程同步。

> #### 乐观锁与悲观锁
> **悲观锁:** **总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁**，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。
>
> **乐观锁:** **总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。** **乐观锁适用于多读的应用类型，这样可以提高吞吐量** ，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。
> 
> **两种锁的使用场景:** 从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。


### 2.3 锁机制
`java.util.concurrent.locks`中定义的`Lock机制`比`synchronized机制`更加强大和灵活。synchronized仅能作用在一段结构化代码中，Lock接口可以适应更复杂的代码结构。具有`tryLock()`方法、`ReadWriteLock接口`等，提供新特性。性能更优越。
1. `ReentrantLock类`：
2. `ReadWriteLock接口`及其实现`类ReentrantReadWriteLock`：
3. `StampedLock类`:
4. `Semaphore`：是一个计数器，用来控制一个或多个共享资源的访问。
5. `CountDownLatch`：可以使一个线程等待多个操作结束。
6. `CyclicBarrier`：可以使多个线程在一个共同状态点同步。
7. `Phaser`：可以分阶段地控制并发任务的执行。只有所有的线程都完成一个阶段后，才能继续下一个阶段。
8. `Exchanger`：能够使得两个线程在某个点进行数据交换。
9. `CompletableFuture`：一个或多个任务等待另外一些任务执行结束，并且这些任务将以异步方式运行。

### 2.4 比较Synchronized，ReentrantLock
> ### Lock和synchronized的区别
> Lock提供了与synchronized关键字类似的同步功能，只是在使用时要显示地获取和释放锁，拥有锁获取与释放的可操作性、可中断地获取锁以及超时获取锁等同步特性。
> - Lock能使线程尝试非阻塞地获取锁，当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁
> - Lock能使线程被中断地获取锁，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常会抛出，锁被释放
> - Lock能使线程超时获取锁，在指定的截止时间之前获取锁，如果截止时间到了仍未获取锁则返货

> ### 抽象队列同步器AbstractQueuedSynchronizer（AQS）
> 抽象同步队列是一个抽象类，是用来构建锁或者其他同步组件的基本框架，核心是使用一个volatile修饰的int变量来标识同步状态，通过一个内置的FIFO队列来完成尝试获取锁的线程的排队工作。通过重写抽象队列同步器的指定方法如tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared等可以设计不同的同步器。
> 
> 同步器提供的模板方法基本分为3类，独占式获取与释放同步状态、共享式获取与释放同步状态和查询同步队列中的等待线程。
> 
> 同步器完成线程同步主要包括同步队列、独占式、共享式、超时同步状态获取与释放的数据结构和模板方法。
>
> **同步队列：** 是一个帮助同步状态管理的FIFO双向队列，队列的节点包含获取同步状态失败的线程的引用、等待状态以及前驱后继节点。当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点，并将其加入同步队列，同时会阻塞当前线程，同步状态释放后，会将首节点的线程唤醒，使其再次尝试获取同步状态。
> 
> **独占式同步状态获取释放：** 获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋，移出队列的条件是前驱节点为头结点且获得同步状态。在释放同步状态时，同步器调用tryRelease方法释放同步状态，唤醒头结点的后继节点。
>
> **共享式同步状态获取释放：** 共享式获取与独占式获取区别在于同一时刻能否有多个线程同时获取到同步状态。
> 
> **独占式超时获取同步状态：** 调用doAcquireNanos(int arg, long nanosTimeout)方法可以超时获取同步状态。

### 背景，应该就是`Synchronized`的缺点
* `Synchronized`产生原因，`原子性(Atomicity)`与`可见性(visibility)`，其中可见性涉及到`JMM`的`happens-before`原语，这又涉及到`Memory Barrier`，推荐这篇文章[《并发导论》][1]

* `Synchronized`使用示例

	```java
    synchronized (lockObject) {
		// update object state
	}
	```

* 但是`Synchronized`存在的缺点是：它无法中断一个正在等候获得锁的线程，也无法通过投票得到锁...同时多个线程争用同一个锁，jvm的总体开销有点大

### `ReentrantLock`
> #### 可重入的实现
> 通过判断当前线程是否为获取锁的线程来决定重入操作是否成功，如果是已获取锁的线程再次请求，则将同步状态值增加并返回true表示成功。相应的，在同步状态释放时也需要判断当前线程是否与占有锁线程是否相同，并且释放同步状态时要减少同步状态量的值。
> #### 公平锁与非公平锁的原理
> **公平锁**是在tryAcquire()尝试获取锁的时候，状态量为0时判断同步队列中当前节点是否有前驱节点，如果有前驱节点，表示有线程比当前线程更早地尝试获取锁，则当前线程需要等待前驱线程获取并释放锁之后才能继续获取锁。
>
> **非公平锁**没有前驱判断，主要获得同步状态就成功获取锁。
>
> **公平锁和非公平锁的比较：** 非公平锁只要获取了同步状态就能成功获取锁，所以刚释放锁的线程再次获取同步状态的概率会非常大，使其他线程在同步队列等待，出现线程“饥饿”情况。公平锁虽然能避免这个问题，但是会出现大量线程切换的问题，带来非常大的开销，影响吞吐量。
* 默认是不公平(`unfair`)锁
* 有一个与锁相关的`获取计数器`，获取一次加一，获取两次加二，注意释放两次才代表真正释放锁

* `ReentrantLock`使用示例

	```java
    ReentrantLock lock = new ReentrantLock();
    lock.lock();
    try {
    	// update object state
    }
    finally {
    	lock.unlock();
    }
	```

* 相比较`Synchronized`，`ReentrantLock`在调度的开支上花的时间相对少，从而为更高的吞吐率留下空间，实现了更有效的CPU利用

### `Condition`
* 对比`JDK 1.4`以前版本中的`Object.wait()`，`Object.notify()`，`Object.notifyAll()`，上述三种线程间同步方式有问题，可问题是什么，需要继续学习，留在`todolist`...

* `Condition`提供`await()`，`signal()`，`signalAll()`用于实现上述功能

* `Condition`使用示例，需要和`ReentrantLock`配合，简单使用参见[《关于JAVA Condition 条件变量》][3]
	```java
    ReentrantLock lock = new ReentrantLock();
    Condition condition = lock.newCondition();
    lock.lock();
    try {
    	condition.await();
    	// update object state
    }
    finally {
    	lock.unlock();
    }
    
    condition.signal();
    condition.signalAll();
    ```
### 那么在什么时候使用`ReentrantLock`
* 需要实现`时间锁等候`，`可中断锁等候`，`无块结构锁`，`多个条件变量`，`锁投票`，`高度争用`的情形

### <a name="JC.03">三、Java中的线程池</a>
### 3.0 使用线程池的优点
> 合理地使用线程池具有三个好处：
> 1. 降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
> 2. 提高响应速度：当任务到达时，任务可以不需要等到线程创建就能够立即执行。
> 3. 提高线程的可管理性：线城是稀缺资源，如果无限制地创建，会消耗系统资源，并且降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。
### 3.1 线程池的实现原理
> 线程池ThreadPoolExecutor执行execute的情况分为四类：
> 1. 如果当前运行线程的数量少于核心线程池容量corePoolSize,则创建新线程来执行任务（执行这一步需要获取全局锁）
> 2. 如果运行线程数等于或多于核心线程池容量corePoolSize，那么将任务加入阻塞队列BlockingQueue
> 3. 如果队列满了，无法将任务加入到阻塞队列BlockingQueue，那么创建新的线程来处理任务（需获取全局锁）
> 4. 如果创建线程后使得线程数超出最大线程池容量maximumPoolSize，那么任务被拒绝执行，并调用饱和策略来处理，使用RejectedExecutionHandler.rejectedExecution()

### 3.2 线程池的使用

> #### 1）使用 `ThreadPoolExecutor` 来创建线程池
> ```java
> new ThreadPoolExecutor(corePoolSize, maximumPoolSize,keepAliveTime, 
> milliseconds, runnableTaskQueue,handler);
> ```
> #### 2）创建线程池的核心参数
> 1. corePoolSize(线程池的基本大小)：当提交一个任务到线程池时，如果已有线程没有达到基本大小，会创建一个新的线程来执行任务，即使其他空闲的**基本线程**能够执行新任务。如果调用线程池的`prestartAllCoreThreads()`方法，则线程池会提前创建并启动所有**基本线程**。
> 2. runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。有以下几种阻塞队列可供选择：
> - ArrayBlockingQueue:是基于数组结构的有界阻塞队列，按FIFO原则添加元素
> - LinkedBlockingQueue:一个基于链表结构的阻塞队列，按FIFO原则添加元素，newFixedThreadPool()使用该队列
> - SynchronousQueue:一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，newCachedThreadPool使用这个队列
> - PriorityBlockingQueue:一个具有优先级的无限阻塞队列
> 3.  maximumPoolSize(线程池最大数量)：线程池允许创建的最大线程数，队列满了且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。
> 4. ThreadFactory:用于设置创建线程的工厂，可以通过线程工厂给每个创建的线程设置名称
> 5. RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略来处理提交的新任务，框架提供4种策略，默认是AbortPolicy
> - AbortPolicy:直接排除异常
> - CallerRunsPolicy:只用调用者所在线程来运行任务
> - DiscardOldestPolicy:丢弃队列里最近的一个任务，并执行当前任务
> - DiscardPolicy:不处理，丢弃掉
> 6. keepAliveTime(线程活动保持时间)：线程池的工作线程空闲后，保持存活的时间。
> 7. TimeUnit（线程活动保持时间的单位）
> #### 3）向线程池提交任务
> - execute()方法用于提交不需要返回值的任务，输入的任务是一个Runnable()类
> - submit()方法用于提交需要返回值的任务，输入的任务是Callable()类或Runnable()类
> #### 4）关闭线程池
> 原理：遍历线程池中的工作线程，逐个调用线程的interrupt方法来中断线程
> - shutdown关闭：将线程池状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程
> - shutdownNow关闭：首先将线程池状态设置成STOP，然后尝试停止所有正在执行或暂停任务的线程
### 四种线程池
- newCachedThreadPool：可缓存的线程池
- newFixedThreadPool：定长线程池
- newSingleThreadExecutor：单线程线程池
- newScheduledThreadPool：支持定时的定长线程池
### <a name="JC.04">四、Java中并发框架</a>

### <a name="JC.05">五、Java中的原子操作类</a>