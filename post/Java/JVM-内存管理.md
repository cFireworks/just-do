### 一、Java内存区域与内存溢出异常（OOM）

### 线程私有区域
> ### 程序计数器
> 
> 程序计数器是一块较小的内存空间，每个线程有一个独立的程序计数器，用作当前线程所执行字节码的行号指示器，帮助完成分支、循环、跳转、异常处理和线程恢复等基础功能。如果线程正在执行的是一个Java方法，计数器记录对应虚拟机字节码指令的地址，如果执行的是本地方法，计数器值为空。
> ### Java虚拟机栈
> Java虚拟机栈也是线程私有的，它描述了Java方法执行的线程内存模型，每个方法被执行时都会在虚拟机栈中创建一个栈帧，用来存放局部变量表、操作数栈、动态连接、方法出口等信息，局部变量数据在局部变量表中以32位的局部变量槽来标识。每个方法的调用执行过程对应着栈帧入栈、出栈的过程。栈空间容量是有限的，如果线程请求的栈深度大于栈空间容量，会出现StackOverflowError异常，申请栈空间申请扩展失败会有OutOfMemoryError异常。
> ### 本地方法栈
> 本地方法栈和虚拟机栈功能相似，用于执行本地方法服务，在HotSpot虚拟机中直接把本地方法栈和虚拟机栈合二为一。


### 线程共享区域
> ### Java堆
> Java堆是被所有线程共享的一块内存区域，用于存放对象实例。Java堆是垃圾收集器管理的内存区域，其中包含内存的回收与分配。从回收内存的角度看，大部分垃圾收集器都是基于分代收集理论，因此Java堆内存可分为新生代、老年代，其中新生代又包含一个Eden和两个Survivor区域。从分配内存的角度来看，所有线程共享的Java堆可以划分出多个线程私有的分配缓冲区（TLAB），可以提升分配效率。Java堆可以处于物理上不连续的内存空间，但在逻辑上是被视为连续的。如果Java堆中没有内存完成实力分配或者堆无法再扩展，则虚拟机会抛出OutOfMemoryError异常。
> ### 方法区
> 方法区用于存储被虚拟机加载的类型信息、常量、静态变量、代码缓存等数据。包括运行时常量池，运行时常量池中包括常量池表，用于存放编译期生成的各种字面量和符号引用，运行期间也可以将新的常量放入池中。方法区是采用本地内存的方式实现的，也可以进行垃圾回收，但是相对出现较少。

### 对象的内存布局
> #### 1）对象头
> - 无锁状态下：对象头Mark Word中包好了25个bit的hashcode，4个bit的分代年龄，2个bit的锁标记（各状态均有）01，1个bit固定为0
> - 偏向锁的状态下：存储偏向线程id，偏向时间戳，对象分代年龄,标志位01
> - 轻量级锁状态下：存储指向锁记录的指针，标志位00
> - 重量级锁状态下：存储指向重量级锁记录的指针，标志位10
> - GC状态下：内容为空，标志位11
> #### 2）对象的生命周期
> 1. **创建阶段(Created)**: 为对象分配存储空间 &rarr; 开始构造对象 &rarr; 从超类到子类对static成员进行初始化 &rarr; 超类成员变量按顺序初始化，递归调用超类的构造方法 &rarr; 子类成员变量按顺序初始化，子类构造方法调用
> 2. **应用阶段(In Use)**：一旦对象被创建，并被分派给某些变量赋值，这个对象的状态就切换到了应用阶段，应用阶段对象至少被一个强引用持有着。
> 3. **不可见阶段(Invisible)**：程序的运行已经超出了该对象的作用域
> 4. **不可达阶段(Unreachable)**：对象处于不可达阶段是指该对象不再被任何强引用所持有，该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”。存在着这些GC root会导致对象的内存泄露情况，无法被回收。
> 5. **收集阶段(Collected)**：
> 当垃圾收集器发现该对象已经处于“不可达阶段”且垃圾收集器已经对该对象所占内存空间的再分配做好准备时，对象进入了“收集阶段”。假设该对象已经重写了finalize()方法，则会去运行该方法。**不要重载finazlie()方法**！原因有两点：
> - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 会影响JVM的对象分配与回收速度:在分配该对象时，JVM须要在垃圾回收器上注冊该对象，以便在回收时可以运行该重载方法；在该方法的运行时须要消耗CPU时间且在运行完该方法后才会又一次运行回收操作，即至少须要垃圾回收器对该对象运行两次GC。
> - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能造成该对象的再次“复活”: 在finalize()方法中，假设有其他的强引用再次持有该对象，则会导致对象的状态由“收集阶段”又又一次变为“应用阶段”。这个已经破坏了Java对象的生命周期进程，且“复活”的对象不利用兴许的代码管理。
> 6. **终结阶段(Finalized)**：当对象**运行完finalize()方法后仍然处于不可达状态时**，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。
> 7. **对象空间重分配阶段(De-allocated)**：垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间又一次分配阶段”。

#### 非虚拟机运行时数据区
1. 直接内存，NIO中一种基于Channel和Buffer的I/O机制，使用Native函数库直接分配堆外内存，再使用DirectBuffer对象作为这种内存的引用进行操作。

### 二、垃圾收集（GC）

#### 关注点——内存模型中Java堆和方法区的内存管理
垃圾收集关注的是Java堆和方法区的内存管理，因为Java堆和方法区中的内存是运行时动态分配的，具有不确定性。
#### 首先——判断对象“存活”还是“死去”
Java堆中存放着几乎所有的对象实例，因此在对堆回收前，首先要确定这些对象实例是否存活，主要有引用计数和可达性分析两种方法来进行判断。
1. 引用计数算法
> 对象添加一个引用计数器，每当一个地方引用它，计数器增加一，引用失效时计数器减一，为零时对象不可被使用。引用计数法很难解决对象之间的循环引用问题。
> 
> Python的GC是基于引用计数算法的，为了解决该算法缺点，使用标记-清除方法来应对循环引用问题，使用分代回收来提高回收效率。
- 优点：原理简单、效率高
- 缺点：耗费资源、无法应对循环引用问题

2. 可达性分析算法
> 以GC Roots为跟对象起点集，从这些起点开始根据引用关系向下搜索，如果某个对象到GC Roots间没有任何引用链，则表示该对象不可达，不可能再被使用。
> - **GC Roots包括**：虚拟机栈中引用的对象；方法去中类静态属性或常量引用的对象；本地方法栈中JNI引用的对象；基本数据类型对应的Class对象；常驻异常对象；系统类加载器；被同步锁持有的对象等等
> - **根节点枚举范围**主要是**全局性的引用（如常量和类静态属性）**与**执行上下文（如栈帧中的本地变量表）**，收集器在根节点枚举时都必须暂停用户线程，即“stop the world”，在一个能保障一致性快照中进行。
> - 根节点枚举时使用一组称为**OopMap**的数据结构来得到哪些地方存放着对象引用，**OopMap记录了对象内什么偏移量上是什么类型数据，也会在特定位置记录下栈和寄存器内哪些位置是引用**。
> - 这些特定位置被称为**安全点**，安全点的选择是以“是否具有让程序长时间执行的特征”为标准来选定的，最明显特征是**指令复用的地方**，在**方法调用、循环跳转、异常跳转等指令**才会产生安全点。
> - **如何让所有线程跑到最近的安全点**，有两种方案：**抢先式中断**和**主动式中断**。1）抢先式中断的思想是在垃圾收集发生时，系统首先把所有的用户线程全部中断，如果有线程中断的地方不在安全点上，就恢复这条线程执行，直到跑到安全点中断。2）主动式中断的思想当垃圾收集需要中断线程时，简单地设置一个标志位，然后不同的线程执行过程中主动去轮询这个标志，一旦发现中断标志为真则在自己最近的安全点位置上主动中断挂起自己。
> - **针对Sleep或Blocked状态下的用户线程，引入安全区域**来解决进入安全点的问题。安全区域是保证在某一代码片段中引用关系不会发生变化。用户线程进入安全区域代码时会标记自己进入安全区域的状态，垃圾收集将会不管安全区域中的线程。如果线程将要离开安全区域，那么他会检查是否已经完成根节点枚举，如果没有完成则必须等待可以离开安全区域的信号。
> - **针对跨代引用的问题，引入记忆集**来避免把整个老年代加进GC Roots扫描范围。记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。通过扩大记录粒度可以优化记忆集的空间占用和维护成本，**以“卡表”的方式来实现记忆集**，是每个记录对应于非收集区域内的一块内存区域，该区域内含有跨代指针，这样可以缩小GC Roots扫描范围。
> - **并发的可达性标记**，引入三色标记来辅助推导，白色未访问，黑色已经全部访问，灰色部分引用未访问。当且仅当插入一条或多条从黑色对象到白色对象的新引用且删除了全部从灰色对象到该白色对象的直接、间接引用时，会将黑色对象误标记为白色。可以使用**增量更新**或**原始快照**的方法分别破坏两个条件来防止对象消失问题。增量更新是当黑色对象一旦插入指向白色对象的引用后，就变回灰色对象了。原始快照是无论引用关系删除与否，都会按照刚开始扫描那一刻的对象图快照来进行搜索。

3. Java中的四类引用
- 强引用：只要强引用关系在，被引用对象不会被回收
- 软引用：只被软引用关联对象，在系统将要发生OOM异常时，列入回收范围进行回收
- 弱引用：只被弱引用关联对象，只能只能生存到下一次垃圾收集发生为止
- 虚引用：虚引用对对象生存不构成影响，无法通过虚引用获得对象实例

4. 对象存活的两次标记
- 第一次标记，可达性分析后对象没有与GC Roots连接的引用链
- 第二次标记，进行一次筛选，该对象是否有必要执行finalize()方法
>若是有必要执行finalize()，对象将进入F-Queue队列，等待执行finalize()方法，还有一线生机。​

5. 方法区中常量和类型的“存活”
- 废弃的常量：没有任何地方引用该常量，则常量废弃
- 不再使用的类：1）该类所有实例被回收；2）加载该类的类加载器被回收；3）该类对应的java.lang.Class对象没有在任何地方被引用。

#### 其次——使用不同的垃圾回收算法
1. 分代收集理论
>基于两个分代假说：​1）弱分代假说：绝大多数对象是朝升夕灭的。2）强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡​3）跨代引用假说：跨代引用相对于同带引用来说仅占极少数​
- 分代：新生代、老年代
- 回收类型：Partial GC（Minor GC,Major GC,Mixed GC）,Full GC

2. 标记-清除算法
>首先标记出需要回收的对象，标记完成后，统一回收掉被标记对象。或者反过来，标记存活对象，回收未被标记对象。​如CMS老年代垃圾收集器。
- 优点：是最基础的收集算法，后续收集算法的基础
- 缺点：1）执行效率不稳定，与需被回收的对象数量相关；2）内存空间的碎片化问题；
>针对空间碎片化问题，可以采用复杂的内存分配器和内存访问器来解决，如“分区空闲分配链表”

3. 标记-复制算法
>例如HotSpot虚拟机的新生代收集器。将新生代内存划分为8:1:1大小比例，其中包括一块较大的Eden空间和两块较小的Survivor空间。​发生垃圾搜集时，将Eden和Survivor中仍存活的对象复制到另一块Survivor空间，再清理Eden和用过的Survivor空间。当​超过10%对象存活时，使用一种“逃生门”安全设计，依赖其他内存区域（老年代）进行分配担保。
- 优点：1）对于内存中多数对象是可回收的情况，复制较少；2）不用考虑空间碎片问题；
- 缺点：1）对于内存中多数对象存活情况，复制较多；3）可用内存缩小；

4. 标记-整理算法
>标记过程与标记-清除算法相同，但后续步骤不是直接清理，而是让所有存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存。
- 优点：减少空间碎片化问题，降低分配内存时的复杂度
- 缺点：1）移动存活对象并更新对这些对象的引用，访问具有较大负担；2）必须全程暂停用户程序才能进行（最新的收集器利用读屏障实现整理过程与用户线程并发执行）；
最后——不同的垃圾收集器

#### 垃圾收集器
> #### 1. 新生代垃圾收集器
> - Serial收集器：Serial是一个单线程工作的收集器，在垃圾收集时会暂停所有工作线程，直到收集结束，使用的是标记复制算法。
> - ParNew收集器：Serial的多线程版本。
> - Parallel Scavenge收集器：与ParNew类似，但是它的目标是达到一个可控制的吞吐量。
> #### 2. 老年代垃圾收集器
> - Serial Old收集器：采用标记整理算法，在CMS并发收集失败时使用。
> - Parallel Old收集器：采用标记整理算法，与Parallel Scavenge收集器配合使用，实现吞吐量优先。
> - CMS收集器：基于标记清除算法的老年代收集器。包含四个过程：1）stop the world后的初始标记，表级GC Roots直接关联的对象；2）并发标记：从GC Roots直接关联对象开始遍历整个对象图，不需要停顿用户线程；3）重新标记：修正并发标记期间因用户线程运行而导致引用变化的标记，需要暂停用户线程；4）并发清除：清理删除掉标记阶段判断已经死亡的对象，可以与用户线程并发进行。
> #### 3. 混合垃圾收集器
> - G First收集器：使用基于Region的堆内存布局，每个Region可以根据需要称为新生代或老年代。