### 一、Java内存区域与内存溢出异常（OOM）

#### 线程私有区域
1. 程序计数器
2. Java虚拟机栈
3. 本地方法栈

#### 线程共享区域
1. Java堆
2. 方法区
>  方法区用于存储被虚拟机加载的类型信息、常量、静态变量、代码缓存等数据。包括运行时常量池。

#### 非虚拟机运行时数据区
1. 直接内存

### 二、垃圾收集（GC）

#### 关注点——内存模型中Java堆和方法区的内存管理
#### 首先——判断对象“存活”还是“死去”
1. 引用计数算法
>Python的GC是基于引用计数算法的，为了解决该算法缺点，使用标记-清除方法来应对循环引用问题，使用分代回收来提高回收效率。
- 优点：原理简单、效率高
- 缺点：耗费资源、无法应对循环引用问题

2. 可达性分析算法
- 通过一系列称为“GC Roots”的根对象作为起始节点集
>GC Roots包括：虚拟机栈中引用的对象；方法去中类静态属性或常量引用的对象；本地方法栈中JNI引用的对象；基本数据类型对应的Class对象；常驻异常对象；系统类加载器；被同步锁持有的对象等等
- 从根节点起根据引用关系向下搜索，搜索路径为“引用链”
- 若某个对象到GC Roots间没有引用链，则不可达

3. Java中的四类引用
- 强引用：只要强引用关系在，被引用对象不会被回收
- 软引用：只被软引用关联对象，在系统将要发生OOM异常时，列入回收范围进行回收
- 弱引用：只被弱引用关联对象，只能只能生存到下一次垃圾收集发生为止
- 虚引用：虚引用对对象生存不构成影响，无法通过虚引用获得对象实例

4. 对象存活的两次标记
- 第一次标记，可达性分析后对象没有与GC Roots连接的引用链
- 第二次标记，进行一次筛选，该对象是否有必要执行finalize()方法
>若是有必要执行finalize()，对象将进入F-Queue队列，等待执行finalize()方法，还有一线生机。​

5. 方法区中常量和类型的“存活”
- 废弃的常量：没有任何地方引用该常量，则常量废弃
- 不再使用的类：1）该类所有实例被回收；2）加载该类的类加载器被回收；3）该类对应的java.lang.Class对象没有在任何地方被引用。

#### 其次——使用不同的垃圾回收算法
1. 分代收集理论
>基于两个分代假说：​1）弱分代假说：绝大多数对象是朝升夕灭的。2）强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡​3）跨代引用假说：跨代引用相对于同带引用来说仅占极少数​
- 分代：新生代、老年代
- 回收类型：Partial GC（Minor GC,Major GC,Mixed GC）,Full GC

2. 标记-清除算法
>首先标记出需要回收的对象，标记完成后，统一回收掉被标记对象。或者反过来，标记存活对象，回收未被标记对象。​
- 优点：是最基础的收集算法，后续收集算法的基础
- 缺点：1）执行效率不稳定，与需被回收的对象数量相关；2）内存空间的碎片化问题；
>针对空间碎片化问题，可以采用复杂的内存分配器和内存访问器来解决，如“分区空闲分配链表”

3. 标记-复制算法
>例如HotSpot虚拟机的新生代收集器。将新生代内存划分为8:1:1大小比例，其中包括一块较大的Eden空间和两块较小的Survivor空间。​发生垃圾搜集时，将Eden和Survivor中仍存活的对象复制到另一块Survivor空间，再清理Eden和用过的Survivor空间。当​超过10%对象存活时，使用一种“逃生门”安全设计，依赖其他内存区域（老年代）进行分配担保。
- 优点：1）对于内存中多数对象是可回收的情况，复制较少；2）不用考虑空间碎片问题；
- 缺点：1）对于内存中多数对象存活情况，复制较多；3）可用内存缩小；

4. 标记-整理算法
>标记过程与标记-清除算法相同，但后续步骤不是直接清理，而是让所有存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存。
- 优点：减少空间碎片化问题，降低分配内存时的复杂度
- 缺点：1）移动存活对象并更新对这些对象的引用，访问具有较大负担；2）必须全程暂停用户程序才能进行（最新的收集器利用读屏障实现整理过程与用户线程并发执行）；
最后——不同的垃圾收集器